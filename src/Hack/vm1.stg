init(generator, date, time, init, nargs, ret) ::= <<
// Generated by <generator> on <date> at <time>

    // Preamble

    // Point SP, LCL and ARG to base of stack
    @256
    D=A
    @SP
    M=D
    @LCL
    M=D
    @ARG
    M=D

    // Point THIS and THAT to base of heap
    @2048
    D=A
    @THIS
    M=D
    @THAT
    M=D

<call(init, nargs, ret)>    

(END)
    @END
    0;JMP

>>

return() ::= <<
    // Prepare return jump
    // Store the top of the frame (FRAME) in temp register R13
    @LCL
    D=M
    @R13
    M=D

    // Store return address *(FRAME - 5) in temp register R14
    @5
    A=D-A
    D=M
    @R14
    M=D

    // Reposition the return value for the caller
    @SP
    AM=M-1
    D=M
    @ARG
    A=M
    M=D

    // Restore SP of the caller
    @ARG
    D=M+1
    @SP
    M=D

    // Restore THAT *(FRAME - 1) of the caller
    @R13
    D=M
    @1
    A=D-A
    D=M
    @THAT
    M=D

    // Restore THIS *(FRAME - 2) of the caller
    @R13
    D=M
    @2
    A=D-A
    D=M
    @THIS
    M=D

    // Restore ARG *(FRAME - 3) of the caller
    @R13
    D=M
    @3
    A=D-A
    D=M
    @ARG
    M=D

    // Restore LCL *(FRAME - 4) of the caller
    @R13
    D=M
    @4
    A=D-A
    D=M
    @LCL
    M=D

    // Jump to return address
    @R14
    A=M
    0;JMP
>>

call(fn, nargs, ret) ::= <<
    // call <fn> <nargs>

    // Push return address
<pushAddress(ret)>

    // Save LCL of caller
<pushMemory("LCL")>

    // Save ARG of caller
<pushMemory("ARG")>

    // Save THIS of caller
<pushMemory("THIS")>

    // Save THAT of caller
<pushMemory("THAT")>

    // Reposition ARG for callee
    @SP
    D=M
    @<nargs>
    D=D-A
    @5
    D=D-A
    @ARG
    M=D

    // Reposition LCL for callee
    @SP
    D=M
    @LCL
    M=D

    // Transfer control
    @<fn>
    0;JMP

(<ret>)
>>

pushLocal(i) ::= <<
    // push local <i>
    D=0
    @SP
    A=M
    M=D
    @SP
    M=M+1
>>

functionDecl(fn, locals) ::= <<
(<fn>)
<locals:{i | 
<pushLocal(i)>    
}>
>>

unaryOp(name, op) ::= <<
    // <name>
    @SP
    AM=M-1
    <op>
    @SP
    M=M+1
>>

binaryOp(name, op) ::= <<
    // <name>
    @SP
    AM=M-1
    D=M
    @SP
    AM=M-1
    <op>
    M=D
    @SP
    M=M+1

>>

logicalOp(name, jump, iftrue) ::= <<
    // <name>
    @SP
    AM=M-1
    D=M
    @SP
    AM=M-1
    D=M-D
    M=-1
    @<iftrue>
    D;<jump>
    @SP
    A=M
    M=0
(<iftrue>)
    @SP
    M=M+1

>>

pushSegment(symbol, segment, index) ::= <<
    // push <segment> <index>

    // 1. calculate target address
    @<symbol>
    D=M
    @<index>
    A=D+A

    // 2. read value
    D=M

    // 3. push value onto stack
    @SP
    A=M
    M=D
    @SP
    M=M+1

>>

popSegment(symbol, segment, index) ::= <<
    // pop <segment> <index>

    // 1. calculate target address and store in R13
    @<symbol>
    D=M
    @<index>
    D=D+A
    @R13
    M=D

    // 2. pop value from stack
    @SP
    AM=M-1
    D=M

    // 3. store value in target address
    @R13
    A=M
    M=D

>>

pushStatic(name, index) ::= <<
    // push static <index>
    @<name>.<index>
    D=M
    @SP
    A=M
    M=D
    @SP
    M=M+1

>>

popStatic(name, index) ::= <<
    // pop static <index>
    @SP
    AM=M-1
    D=M
    @<name>.<index>
    M=D
    
>>

pushAddress(addr) ::= <<
    @<addr>
    D=A
    @SP
    A=M
    M=D
    @SP
    M=M+1
>>

pushMemory(addr) ::= <<
    @<addr>
    D=M
    @SP
    A=M
    M=D
    @SP
    M=M+1
>>

ifGoto(label) ::= <<
    // if-goto <label>
    @SP
    AM=M-1
    D=M
    @<label>
    D;JNE
>>

goto(label) ::= <<
    // goto <label>
    @<label>
    0;JMP
>>

pushConstant(value) ::= <<
    // push constant <value>    
<pushAddress(value)>

>>